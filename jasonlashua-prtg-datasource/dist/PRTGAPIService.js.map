{"version":3,"sources":["../src/PRTGAPIService.js"],"names":["PRTGAPIService","alertSrv","backendSrv","PRTGAPI","api_url","username","passhash","cacheTimeoutMinutes","url","lastId","cache","Date","now","hashValue","Promise","resolve","data","getCache","str","hash","length","idx","chr","charCodeAt","val","slice","unixtime","dt","getFullYear","pad","getMonth","getDate","getHours","getMinutes","getSeconds","join","method","params","queryString","options","inCache","setCache","datasourceRequest","then","response","reject","message","groups","devices","sensors","channels","values","sensordata","messages","Version","XMLXform","console","log","error","status","statusText","performPRTGAPIRequest","groupFilter","deviceFilter","items","queryStr","invert","filterItems","match","_","trim","split","push","filter","findItem","item","group","device","sensor","name","utils","isRegex","rex","buildRegex","result","test","includes","performGroupSuggestQuery","filterQuery","hostFilter","performDeviceSuggestQuery","getGroups","filters","each","filteredGroups","sensorFilter","getHosts","hosts","host","performSensorSuggestQuery","getSensors","promises","map","objid","all","channel","sensor_raw","flatten","channelFilter","invertChannelFilter","getAllItems","target","getItems","dateFrom","dateTo","hours","avg","getTimezoneOffset","getPRTGDate","history","results","histdata","rCnt","testdata","chanIndex","value_raw","RegExp","escapeRegex","iter","prtgDate","datetime_raw","Number","text","datetime","value","from","to","sensorId","events","time","Math","round","title","parent","type","angular","module","factory"],"mappings":"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","file":"PRTGAPIService.js","sourcesContent":["import angular from \"angular\";\nimport _ from \"lodash\";\nimport * as utils from \"./utils\";\nimport { XMLXform } from \"./xmlparser\";\n/**\n * PRTG API Service\n * Implements the high level functions that process data from PRTG\n */\n\n/** @ngInject */\nfunction PRTGAPIService(alertSrv, backendSrv) {\n  class PRTGAPI {\n    constructor(api_url, username, passhash, cacheTimeoutMinutes) {\n      this.url = api_url;\n      this.username = username;\n      this.passhash = passhash;\n      this.lastId = false;\n      this.cache = {};\n      this.cacheTimeoutMinutes = cacheTimeoutMinutes;\n      this.alertSrv = alertSrv;\n      this.backendSrv = backendSrv;\n    }\n\n    /**\n     * Tests whether a url has been stored in the cache.\n     * Returns boolean true | false\n     *\n     * @param url\n     * @return boolean\n     */\n    inCache(url) {\n      if (\n        Date.now() - this.cache[this.hashValue(url)] >\n        this.cacheTimeoutMinutes * 60 * 1000\n      ) {\n        return false;\n      }\n      if (this.cache[this.hashValue(url)]) {\n        return true;\n      }\n      return false;\n    }\n\n    /**\n     * retrieves a cached data result from the cache\n     *\n     * @param  url the URL of the request\n     * @return Promise\n     */\n    getCache(url) {\n      return Promise.resolve(this.cache[this.hashValue(url)]);\n    }\n\n    /**\n     * stores a data result in the cache\n     *\n     * @param  url the URL of the request\n     * @param  data the response.data object of the request\n     * @return promise\n     */\n    setCache(url, data) {\n      this.cache[this.hashValue(url)] = data;\n      return this.getCache(url);\n    }\n\n    /**\n     * simple clone of a java hash value\n     * Kevin \"Pancake\" (http://werxltd.com/wp/2010/05/13/javascript-implementation-of-javas-string-hashcode-method/)\n     *\n     * @param  e string to hash\n     * @return int32\n     */\n    hashValue(str) {\n      let hash = 0;\n      if (str.length === 0) return hash;\n      for (let idx = 0; idx < str.length; idx++) {\n        const chr = str.charCodeAt(idx);\n        hash = (hash << 5) - hash + chr;\n        hash = hash & hash; // Convert to 32bit integer\n      }\n      return hash;\n    }\n\n    /**\n     * pad date parts and optionally add one\n     */\n    pad(idx, val) {\n      if (val) return (\"0\" + (idx + 1)).slice(-2);\n      return (\"0\" + idx).slice(-2);\n    }\n\n    /**\n     * convert a UNIX timestamp into a PRTG date string for queries\n     * YYYY-MM-DD-HH-MM-SS\n     *\n     * @param unixtime UNIX format timestamp\n     */\n    getPRTGDate(unixtime) {\n      const dt = new Date(unixtime * 1000);\n      const str = [\n        dt.getFullYear(),\n        this.pad(dt.getMonth(), true),\n        this.pad(dt.getDate()),\n        this.pad(dt.getHours()),\n        this.pad(dt.getMinutes()),\n        this.pad(dt.getSeconds())\n      ];\n      return str.join(\"-\");\n    }\n\n    /**\n     * Request data from PRTG API\n     *\n     * @param  method the API method (e.g., table.json)\n     * @param  params HTTP query string query parameters\n     * @return promise\n     */\n    performPRTGAPIRequest(method, params) {\n      const queryString =\n        \"username=\" +\n        this.username +\n        \"&passhash=\" +\n        this.passhash +\n        \"&\" +\n        params;\n      const options = {\n        method: \"GET\",\n        url: this.url + \"/\" + method + \"?\" + queryString\n      };\n\n      if (this.inCache(options.url)) {\n        return this.getCache(options.url);\n      } else {\n        return this.setCache(\n          options.url,\n          this.backendSrv.datasourceRequest(options).then(\n            response => {\n              if (!response.data) {\n                return Promise.reject({\n                  message: \"Response contained no data\"\n                });\n              }\n\n              if (response.data.groups) {\n                return response.data.groups;\n              } else if (response.data.devices) {\n                return response.data.devices;\n              } else if (response.data.sensors) {\n                return response.data.sensors;\n              } else if (response.data.channels) {\n                return response.data.channels;\n              } else if (response.data.values) {\n                return response.data.values;\n              } else if (response.data.sensordata) {\n                return response.data.sensordata;\n              } else if (response.data.messages) {\n                return response.data.messages;\n              } else if (response.data.Version) {\n                return response.data;\n              } else {\n                //All else must be XML from table.xml so throw it into the transformer and get JSON back.\n                if (response.data == \"Not enough monitoring data\") {\n                  //Fixes Issue #5 - reject the promise with a message. The message is displayed instead of an uncaught exception.\n                  return Promise.reject({\n                    message:\n                      \"Not enough monitoring data.\\n\\nRequest:\\n\" +\n                      params +\n                      \"\\n\"\n                  });\n                }\n                if (response.data.length > 200) {\n                  return new XMLXform(method, response.data);\n                } else {\n                  console.log(\"Short Response! :( \\n\" + response.data);\n                  return {};\n                }\n              }\n            },\n            error => {\n              return Promise.reject(error.status + \": \" + error.statusText);\n            }\n          )\n        );\n      }\n    }\n\n    /**\n     * Only used in connection testing\n     *\n     * @return Promise\n     */\n    getVersion() {\n      return this.performPRTGAPIRequest(\"status.json\").then(function(response) {\n        if (!response) {\n          return \"ERROR. No response.\";\n        } else {\n          return response.Version;\n        }\n      });\n    }\n\n    /**\n     * Authenticate to the PRTG interface\n     * Only used in connection testing because PRTG API is sessionless.\n     *\n     * @return Promise\n     */\n    performPRTGAPILogin() {\n      const username = this.username;\n      const passhash = this.passhash;\n      const options = {\n        method: \"GET\",\n        url:\n          this.url +\n          \"/getstatus.htm?id=0&username=\" +\n          username +\n          \"&passhash=\" +\n          passhash\n      };\n      return this.backendSrv.datasourceRequest(options).then(response => {\n        this.passhash = response;\n        return response;\n      });\n    }\n\n    /**\n     * Query API for list of groups\n     *\n     * @return Promise - JSON result set\n     */\n    performGroupSuggestQuery() {\n      const params =\n        \"content=groups&count=9999&columns=objid,group,probe,tags,active,status,message,priority\";\n      return this.performPRTGAPIRequest(\"table.json\", params);\n    }\n\n    /**\n     * Query API for list of devices\n     * @param {string} groupFilter - raw string, comma separated strings, or regular expression pattern\n     * @return Promise - JSON result set\n     */\n    performDeviceSuggestQuery(groupFilter) {\n      let params =\n        \"content=devices&count=9999&columns=objid,device,group,probe,tags,active,status,message,priority\";\n      if (groupFilter) {\n        params += \",group\" + groupFilter;\n      }\n      return this.performPRTGAPIRequest(\"table.json\", params);\n    }\n\n    /**\n     * Query API for list of sensors bound to a given device\n     * @param {string} deviceFilter - raw string, comma separated strings, or regular expression pattern\n     * @return promise - JSON result set\n     */\n    performSensorSuggestQuery(deviceFilter) {\n      let params =\n        \"content=sensors&count=9999&columns=objid,sensor,device,group,probe,tags,active,status,message,priority\";\n      if (deviceFilter) {\n        params += deviceFilter;\n      }\n\n      return this.performPRTGAPIRequest(\"table.json\", params);\n    }\n\n    /**\n     * Filter a PRTG collection against a filter string\n     *\n     * @param {collection} items - PRTG Data object\n     * @param {string} queryStr - Query filter, raw string, comma separated strings, or regular expression pattern\n     * @param {boolean} invert - when set to boolean true, negates the return value.\n     * @return {boolean} result of text expression\n     */\n    filterQuery(items, queryStr, invert = false) {\n      /**\n       * group device sensor includes properties:\n       * objid: num\n       * sensor: Name\n       * device: Device name\n       * group: Group name\n       * tags: comma separated\n       * active: true|false\n       * active_raw: -1 for true? wtf\n       * status: Status text\n       * status_raw: number\n       * message: html message\n       * message_raw: text message\n       * priority: number 1-5\n       */\n      let filterItems = [];\n      if (queryStr.match(/{[^{}]+}/g)) {\n        filterItems = _.trim(queryStr, \"{}\").split(\",\");\n      } else {\n        filterItems.push(queryStr);\n      }\n      return _.filter(items, item => {\n        let findItem;\n        if (item.group && !item.device) {\n          findItem = item.group;\n        } else if (item.device && !item.sensor) {\n          findItem = item.device;\n        } else if (item.sensor && !item.name) {\n          findItem = item.sensor;\n        } else if (item.name) {\n          findItem = item.name;\n        } else {\n          return false;\n        }\n        if (utils.isRegex(queryStr)) {\n          const rex = utils.buildRegex(queryStr);\n          const result = rex.test(findItem);\n          if (invert) {\n            return !result;\n          }\n          return result;\n        }\n        if (filterItems.length === 0) {\n          return true;\n        }\n        if (invert) {\n          return !filterItems.includes(findItem);\n        }\n        return filterItems.includes(findItem);\n      });\n    }\n\n    /**\n     * Retrive groups and filter with an optional filter string\n     *\n     * @param {string} groupFilter - raw string, comma separated strings, or regular expression pattern\n     * @return {collection} - filtered PRTG data object\n     */\n    getGroups(groupFilter = \"/.*/\") {\n      return this.performGroupSuggestQuery().then(groups => {\n        return this.filterQuery(groups, groupFilter);\n      });\n    }\n\n    /**\n     * Retrieve hosts and filter with an optional filter string.\n     *\n     * @param {*} groupFilter - raw string, comma separated strings, or regular expression pattern\n     * @param {*} hostFilter - raw string, comma separated strings, or regular expression pattern\n     * @return {collection} - filtered PRTG data object\n     */\n    getHosts(groupFilter = \"/.*/\", hostFilter = \"/.*/\") {\n      //this is kind of silly but no need to include filter_group params if you include all...\n      if (groupFilter == \"/.*/\") {\n        return this.performDeviceSuggestQuery().then(devices => {\n          return this.filterQuery(devices, hostFilter);\n        });\n      } else {\n        return this.getGroups(groupFilter).then(filteredGroups => {\n          const filters = [];\n          _.each(filteredGroups, group => {\n            filters.push(\"filter_group=\" + group.group);\n          });\n\n          return this.performDeviceSuggestQuery(\n            \"&\" + filters.join(\"&\")\n          ).then(devices => {\n            return this.filterQuery(devices, hostFilter);\n          });\n        });\n      }\n    }\n\n    /**\n     * Retrieve sensors and filter with an optional filter string.\n     *\n     * @param {string} groupFilter - raw string, comma separated strings, or regular expression pattern\n     * @param {string} hostFilter - raw string, comma separated strings, or regular expression pattern\n     * @param {string} sensorFilter - raw string, comma separated strings, or regular expression pattern\n     * @return {collection} - filtered PRTG data object\n     */\n    getSensors(\n      groupFilter = \"/.*/\",\n      hostFilter = \"/.*/\",\n      sensorFilter = \"/.*/\"\n    ) {\n      return this.getHosts(groupFilter, hostFilter).then(hosts => {\n        const filters = [];\n        _.each(hosts, host => {\n          filters.push(\"filter_device=\" + host.device);\n        });\n        if (hostFilter == \"/.*/\" && groupFilter == \"/.*/\") {\n          return this.performSensorSuggestQuery().then(sensors => {\n            return this.filterQuery(sensors, sensorFilter);\n          });\n        } else {\n          return this.performSensorSuggestQuery(\n            \"&\" + filters.join(\"&\")\n          ).then(sensors => {\n            return this.filterQuery(sensors, sensorFilter);\n          });\n        }\n      });\n    }\n\n    /**\n     * Retrieve full data object with channel definitions using an optional filter string\n     *\n     * @param {*} groupFilter - raw string, comma separated strings, or regular expression pattern\n     * @param {*} hostFilter - raw string, comma separated strings, or regular expression pattern\n     * @param {*} sensorFilter - raw string, comma separated strings, or regular expression pattern\n     * @return {collection} - PRTG data object with channel and sensor properties\n     */\n    getAllItems(\n      groupFilter = \"/.*/\",\n      hostFilter = \"/.*/\",\n      sensorFilter = \"/.*/\"\n    ) {\n      return this.getSensors(\n        groupFilter,\n        hostFilter,\n        sensorFilter\n      ).then(sensors => {\n        /**\n         * In this context, if i simply iterate an array with _.each and then execute performPRTGAPIRequest, even\n         * though the returned object is a promise which can be used in a chain, the execution falls outside of the existing\n         * promise chain and thus executs asynchronously. To keep everything in the same execution context, create a\n         * promise array for each object, then execute them in context.\n         */\n        const promises = _.map(sensors, sensor => {\n          const params =\n            \"content=channels&columns=sensor,name&id=\" + sensor.objid;\n          return this.performPRTGAPIRequest(\n            \"table.json\",\n            params\n          ).then(channels => {\n            /**\n             * Create an object that contains all of the information necessary to query this metric.\n             * This information will be used at render time to group the datapoints and name them.\n             */\n            return Promise.all(\n              _.map(channels, channel => {\n                channel.sensor = sensor.objid;\n                channel.sensor_raw = sensor.sensor;\n                channel.device = sensor.device;\n                channel.group = sensor.group;\n                channel.channel = channel.name;\n                return channel;\n              })\n            );\n          });\n        });\n        return Promise.all(promises).then(_.flatten);\n      });\n    }\n\n    /**\n     * Retrieve full data object with channel definitions using an optional filter string.\n     * The results are then filtered against a channelFilter expression.\n     *\n     * @param {string} groupFilter - raw string, comma separated strings, or regular expression patter\n     * @param {string} deviceFilter - raw string, comma separated strings, or regular expression patter\n     * @param {string} sensorFilter - raw string, comma separated strings, or regular expression pattern\n     * @param {string} channelFilter - raw string, comma separated strings, or regular expression pattern\n     * @param {boolean} invertChannelFilter - if set to boolean true, negates the result of the channelFilter expression\n     */\n    getItems(\n      groupFilter,\n      deviceFilter,\n      sensorFilter,\n      channelFilter,\n      invertChannelFilter = false\n    ) {\n      return this.getAllItems(\n        groupFilter,\n        deviceFilter,\n        sensorFilter\n      ).then(items => {\n        return this.filterQuery(items, channelFilter, invertChannelFilter);\n      });\n    }\n    getItemsFromTarget(target) {\n      if (target.options) {\n        if (target.options.invertChannelFilter) {\n          return this.getItems(\n            target.group.name,\n            target.device.name,\n            target.sensor.name,\n            target.channel.name,\n            true\n          );\n        } else {\n          return this.getItems(\n            target.group.name,\n            target.device.name,\n            target.sensor.name,\n            target.channel.name\n          );\n        }\n      }\n      return this.getItems(\n        target.group.name,\n        target.device.name,\n        target.sensor.name,\n        target.channel.name\n      );\n    }\n\n    /**\n     * Retrieve history data from a single sensor.\n     * @param {number} sensor - sensor ID\n     * @param {string} channel - channel name\n     * @param {number} dateFrom - timestamp of start time\n     * @param {number} dateTo - timestamp of end time\n     */\n    getItemHistory(sensor, channel, dateFrom, dateTo) {\n      const hours = (dateTo - dateFrom) / 3600;\n      let avg = 0;\n      if (hours > 12 && hours < 36) {\n        avg = \"300\";\n      } else if (hours > 36 && hours < 745) {\n        avg = \"3600\";\n      } else if (hours > 745) {\n        avg = \"86400\";\n      }\n\n      if (new Date().getTimezoneOffset() < 0 || new Date().getTimezoneOffset() > 0) {\n        dateFrom = dateFrom + (new Date().getTimezoneOffset() * 60);\n        dateTo = dateTo + (new Date().getTimezoneOffset() * 60);\n      }\n\n      const method = \"historicdata.xml\";\n      const params =\n        \"id=\" +\n        sensor +\n        \"&sdate=\" +\n        this.getPRTGDate(dateFrom) +\n        \"&edate=\" +\n        this.getPRTGDate(dateTo) +\n        \"&avg=\" +\n        avg +\n        \"&pctshow=false&pctmode=false\";\n      /*\n             * Modified to read the \"statusid\" value, this can then be mapped via lookup table to a PRTG status type\n             * 1=Unknown, 2=Scanning, 3=Up, 4=Warning, 5=Down, 6=No Probe, 7=Paused by User, 8=Paused by Dependency,\n             * 9=Paused by Schedule, 10=Unusual, 11=Not Licensed, 12=Paused Until, 13=Down Acknowledged, 14=Down Partial\n             */\n      const history = [];\n      return this.performPRTGAPIRequest(method, params).then(results => {\n        if (!results.histdata) {\n          return history;\n        }\n        const rCnt = results.histdata.item.length;\n        const testdata = results.histdata.item[0];\n        let chanIndex = 0;\n\n\n        if (\n          testdata.value_raw &&\n          testdata.value_raw.length > 0\n        )\n        {\n          //try to get idx numbers on first row, saves cycles.\n          for (let idx = 0; idx < testdata.value_raw.length; idx++) {\n            // this hack specifically applies to bandwidth sensors that track speed AND volume, a better solution remains to be implemented.\n            if (testdata.value_raw[idx].channel.match(channel + \" [(]speed[)]\") || testdata.value_raw[idx].channel == channel)\n            {\n              chanIndex = idx;\n            }\n            //\n            else\n            {\n              let rex = new RegExp(utils.escapeRegex(channel), 'g');\n              if (rex.test(testdata.value_raw[idx].channel)) {\n                chanIndex = idx;\n              }\n            }\n          }\n        }\n\n\n        for (let iter = 0; iter < rCnt; iter++) {\n          let val;\n          const prtgDate = results.histdata.item[iter].datetime_raw;\n          const dt = new Date((prtgDate - 25569) * 86400 * 1000);\n          //var dt = Math.round((results.histdata.item[i].datetime_raw - 25568) * 86400,0) * 1000;\n          if (\n            results.histdata.item[iter].value_raw &&\n              results.histdata.item[iter].value_raw.length > 0\n          ) {\n            //FIXME: better way of dealing with multiple channels of same name\n            //IE you select \"Traffic In\" but PRTG provides Volume AND Speed channels.\n          /*\n            for (\n              let iter2 = 0;\n              iter2 < results.histdata.item[iter].value_raw.length;\n              iter2++\n            ) {\n              //workaround for SNMP Bandwidth Issue #3. Check for presence of (speed) suffix, and use that.\n               if (\n                results.histdata.item[iter].value_raw[iter2].channel.match(\n                  channel + \" [(]speed[)]\"\n                ) ||\n                  results.histdata.item[iter].value_raw[iter2].channel == channel\n              )\n              {\n                val = Number(results.histdata.item[iter].value_raw[iter2].text);\n              }\n              */\n            val = Number(results.histdata.item[iter].value_raw[chanIndex].text);\n          //            }\n          } else if (results.histdata.item[iter].value_raw) {\n            val = Number(results.histdata.item[iter].value_raw.text);\n          }\n          history.push({\n            sensor: sensor,\n            channel: channel,\n            datetime: dt,\n            value: val\n          });\n        }\n        return history;\n      });\n    }\n\n    /**\n     * Retrieve messages for a given sensor. Used only for annotation queries.\n     *\n     * @param {number} from - Earliest time in range\n     * @param {number} to - Latest time in range\n     * @param {number} sensorId - Numeric ID of Sensor\n     */\n    getMessages(from, to, sensorId) {\n      const method = \"table.json\";\n      const params =\n        \"&content=messages&columns=objid,datetime,parent,type,name,status,message&id=\" +\n        sensorId;\n      return this.performPRTGAPIRequest(method, params).then(function(\n        messages\n      ) {\n        const events = [];\n        let time = 0;\n        _.each(messages, function(message) {\n          time = Math.round((message.datetime_raw - 25569) * 86400, 0);\n          if (time > from && time < to) {\n            events.push({\n              time: time * 1000,\n              title: message.status,\n              text:\n                \"<p>\" +\n                message.parent +\n                \"(\" +\n                message.type +\n                \") Message:<br>\" +\n                message.message +\n                \"</p>\"\n            });\n          }\n        });\n        return events;\n      });\n    }\n  }\n  return PRTGAPI;\n}\n\n//register a new module\nangular.module(\"grafana.services\").factory(\"PRTGAPIService\", PRTGAPIService);\n"]}