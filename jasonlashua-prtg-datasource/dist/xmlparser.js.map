{"version":3,"sources":["../src/xmlparser.js"],"names":["XMLXform","method","xmlString","xml","undefined","xslt","xslt2","window","DOMParser","parser","parseFromString","xsltProcessor","XSLTProcessor","importStylesheet","newxml","transformToDocument","xsltProcessor2","json","transformToFragment","document","textContent","JSON","parse"],"mappings":";;;;;;;;;;;;;;;;gCAoBaA,Q,GACX,kBAAYC,MAAZ,EAAoBC,SAApB,EAA+B;AAAA;;AAE7B,qBAAKC,GAAL,GAAWC,SAAX;AACA,qBAAKC,IAAL;;AAqCA,qBAAKC,KAAL;;AAwEA,oBAAIC,OAAOC,SAAX,EAAsB;AACpB,wBAAMC,SAAS,IAAID,SAAJ,EAAf;AACA,yBAAKL,GAAL,GAAWM,OAAOC,eAAP,CAAuBR,SAAvB,EAAkC,iBAAlC,CAAX;AACA,yBAAKG,IAAL,GAAYI,OAAOC,eAAP,CAAuB,KAAKL,IAA5B,EAAkC,iBAAlC,CAAZ;AACA,yBAAKC,KAAL,GAAaG,OAAOC,eAAP,CAAuB,KAAKJ,KAA5B,EAAmC,iBAAnC,CAAb;AACD;AACD,oBAAMK,gBAAgB,IAAIC,aAAJ,EAAtB;AACAD,8BAAcE,gBAAd,CAA+B,KAAKR,IAApC;AACA,oBAAMS,SAASH,cAAcI,mBAAd,CAAkC,KAAKZ,GAAvC,CAAf;AACA;AACA,oBAAMa,iBAAiB,IAAIJ,aAAJ,EAAvB;AACAI,+BAAeH,gBAAf,CAAgC,KAAKP,KAArC;AACA,oBAAMW,OAAOD,eAAeE,mBAAf,CAAmCJ,MAAnC,EAA2CK,QAA3C,EAAqDC,WAAlE;AACA,uBAAOC,KAAKC,KAAL,CAAWL,IAAX,CAAP;AACD,a","file":"xmlparser.js","sourcesContent":["/**\n * Grafana Datasource Plugin for PRTG API Interface\n * XML Transformation and Conversion to JSON\n * \n * 20151206 03:10 Jason Lashua\n * Proof of Concept. Based on publicly available plugins.\n *\n * PRTG sends data by channel, both formatted and raw, so like:\n * value 100%, channel 1\n * value_raw 100%, channel 1\n * value 3 gb/s, channel 2\n * value_raw 30492059, channel 2\n *\n * the nodes being unrelated results in repeat objects.\n *\n * first xsl sorts nodes by name, such that all <value> elements are\n * together, and all <value_raw> elements are together.\n * This results in arrays being created, which we can use.\n *\n */\nexport class XMLXform {\n  constructor(method, xmlString) {\n    \n    this.xml = undefined;\n    this.xslt = `<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">\n    <!--<xsl:output method=\"text\" encoding=\"utf-8\"/>-->\n\n<xsl:key name=\"kvalue\" match=\"value\" use=\"@channelid\" />\n<xsl:key name=\"kvalue_raw\" match=\"value_raw\" use=\"@channelid\" />\n\n\n <xsl:template match=\"histdata\">\n    <xsl:copy>\n        <xsl:apply-templates select=\"item\"/>\n    </xsl:copy>\n</xsl:template>\n\n<xsl:template match=\"item\">\n    <xsl:copy>\n        <xsl:apply-templates select=\"datetime\" />\n        <xsl:apply-templates select=\"datetime_raw\" />\n        <xsl:apply-templates select=\"value\">\n            <xsl:sort select=\"@channelid\" data-type=\"number\" order=\"ascending\" />\n        </xsl:apply-templates>\n        <xsl:apply-templates select=\"value_raw\">\n            <xsl:sort select=\"@channelid\" data-type=\"number\" order=\"ascending\" />\n        </xsl:apply-templates>\n    </xsl:copy>\n</xsl:template>\n<xsl:template match=\"item\">\n    <xsl:copy>\n        <xsl:copy-of select=\"datetime\" />\n        <xsl:copy-of select=\"datetime_raw\" />\n        <xsl:copy-of select=\"value\" />\n        <xsl:copy-of select=\"value_raw\" />\n    </xsl:copy>\n</xsl:template>\n</xsl:stylesheet>\n`;\n\n    this.xslt2 = `<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">\n    <xsl:output method=\"text\" encoding=\"utf-8\"/>\n \n    <xsl:template match=\"/*[node()]\">\n        <xsl:text>{</xsl:text>\n        <xsl:apply-templates select=\".\" mode=\"detect\" />\n        <xsl:text>}</xsl:text>\n    </xsl:template>\n \n    <xsl:template match=\"*\" mode=\"detect\">\n        <xsl:choose>\n            <xsl:when test=\"name(preceding-sibling::*[1]) = name(current()) and name(following-sibling::*[1]) != name(current())\">\n                    <xsl:apply-templates select=\".\" mode=\"obj-content\" />\n                <xsl:text>]</xsl:text>\n                <xsl:if test=\"count(following-sibling::*[name() != name(current())]) &gt; 0\">, </xsl:if>\n            </xsl:when>\n            <xsl:when test=\"name(preceding-sibling::*[1]) = name(current())\">\n                    <xsl:apply-templates select=\".\" mode=\"obj-content\" />\n                    <xsl:if test=\"name(following-sibling::*) = name(current())\">, </xsl:if>\n            </xsl:when>\n            <xsl:when test=\"following-sibling::*[1][name() = name(current())]\">\n                <xsl:text>\"</xsl:text><xsl:value-of select=\"name()\"/><xsl:text>\" : [</xsl:text>\n                    <xsl:apply-templates select=\".\" mode=\"obj-content\" /><xsl:text>, </xsl:text>\n            </xsl:when>\n            <xsl:when test=\"count(./child::*) > 0 or count(@*) > 0\">\n                <xsl:text>\"</xsl:text><xsl:value-of select=\"name()\"/>\" : <xsl:apply-templates select=\".\" mode=\"obj-content\" />\n                <xsl:if test=\"count(following-sibling::*) &gt; 0\">, </xsl:if>\n            </xsl:when>\n            <xsl:when test=\"count(./child::*) = 0\">\n                <xsl:text>\"</xsl:text><xsl:value-of select=\"name()\"/>\" : \"<xsl:apply-templates select=\".\"/><xsl:text>\"</xsl:text>\n                <xsl:if test=\"count(following-sibling::*) &gt; 0\">, </xsl:if>\n            </xsl:when>\n        </xsl:choose>\n    </xsl:template>\n \n    <xsl:template match=\"*\" mode=\"obj-content\">\n        <xsl:text>{</xsl:text>\n            <xsl:apply-templates select=\"@*\" mode=\"attr\" />\n            <xsl:if test=\"count(@*) &gt; 0 and (count(child::*) &gt; 0 or text())\">, </xsl:if>\n            <xsl:apply-templates select=\"./*\" mode=\"detect\" />\n            <xsl:if test=\"count(child::*) = 0 and text() and not(@*)\">\n                <xsl:text>\"</xsl:text><xsl:value-of select=\"name()\"/>\" : \"<xsl:value-of select=\"text()\"/><xsl:text>\"</xsl:text>\n            </xsl:if>\n            <xsl:if test=\"count(child::*) = 0 and text() and @*\">\n                <xsl:text>\"text\" : \"</xsl:text><xsl:value-of select=\"text()\"/><xsl:text>\"</xsl:text>\n            </xsl:if>\n        <xsl:text>}</xsl:text>\n        <xsl:if test=\"position() &lt; last()\">, </xsl:if>\n    </xsl:template>\n \n    <xsl:template match=\"@*\" mode=\"attr\">\n        <xsl:text>\"</xsl:text><xsl:value-of select=\"name()\"/>\" : \"<xsl:value-of select=\".\"/><xsl:text>\"</xsl:text>\n        <xsl:if test=\"position() &lt; last()\">,</xsl:if>\n    </xsl:template>\n \n    <xsl:template match=\"node/@TEXT | text()\" name=\"removeBreaks\">\n        <xsl:param name=\"pText\" select=\"normalize-space(.)\"/>\n        <xsl:choose>\n            <xsl:when test=\"not(contains($pText, '&#xA;'))\"><xsl:copy-of select=\"$pText\"/></xsl:when>\n            <xsl:otherwise>\n                <xsl:value-of select=\"concat(substring-before($pText, '&#xD;&#xA;'), ' ')\"/>\n                <xsl:call-template name=\"removeBreaks\">\n                    <xsl:with-param name=\"pText\" select=\"substring-after($pText, '&#xD;&#xA;')\"/>\n                </xsl:call-template>\n            </xsl:otherwise>\n        </xsl:choose>\n    </xsl:template>\n \n</xsl:stylesheet>\n`;\n\n    if (window.DOMParser) {\n      const parser = new DOMParser();  \n      this.xml = parser.parseFromString(xmlString, \"application/xml\");\n      this.xslt = parser.parseFromString(this.xslt, \"application/xml\");\n      this.xslt2 = parser.parseFromString(this.xslt2, \"application/xml\");\n    }\n    const xsltProcessor = new XSLTProcessor();\n    xsltProcessor.importStylesheet(this.xslt);\n    const newxml = xsltProcessor.transformToDocument(this.xml);\n    // Using a separate XSLTProcessor instance resolves issue with Firefox.\n    const xsltProcessor2 = new XSLTProcessor();\n    xsltProcessor2.importStylesheet(this.xslt2);\n    const json = xsltProcessor2.transformToFragment(newxml, document).textContent;\n    return JSON.parse(json);\n  }\n}\n\n"]}